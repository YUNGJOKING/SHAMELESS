<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SHAMELESS Chat & Voice</title>
  <style>
    /* Black & purple theme */
    body {
      margin: 0; font-family: Arial, sans-serif;
      background-color: #1a001a;
      color: #c399ff;
      display: flex; flex-direction: column; height: 100vh;
    }
    header {
      background: #330033; padding: 1em; text-align: center;
      font-size: 1.5em; font-weight: bold;
      border-bottom: 2px solid #c399ff;
      display: flex; justify-content: space-between; align-items: center;
    }
    #usernameDisplay {
      font-size: 1em;
      font-style: italic;
      color: #d9b3ff;
    }
    #chat {
      flex: 1; overflow-y: auto; padding: 1em;
      background: #2a002a;
    }
    #messages {
      list-style: none; padding: 0; margin: 0;
      height: 250px;
      overflow-y: auto;
      border: 1px solid #660066;
      border-radius: 8px;
      background: #220022;
    }
    #messages li {
      margin-bottom: 0.5em;
      word-wrap: break-word;
    }
    #messages li span.username {
      font-weight: bold;
      color: #d9b3ff;
    }
    #chat-input {
      display: flex; background: #330033; padding: 0.5em;
      border-top: 2px solid #c399ff;
    }
    #chat-input input[type="text"] {
      flex: 1;
      padding: 0.5em;
      border: none;
      background: #1a001a;
      color: #c399ff;
      font-size: 1em;
    }
    #chat-input button {
      background: #660066;
      border: none;
      color: #c399ff;
      padding: 0 1em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
    }
    #chat-input button:disabled {
      background: #440044;
      cursor: not-allowed;
    }
    /* VC controls */
    #vc-controls {
      background: #330033;
      padding: 0.5em;
      display: flex;
      justify-content: center;
      gap: 1em;
      border-top: 2px solid #c399ff;
    }
    #vc-controls button {
      background: #660066;
      border: none;
      color: #c399ff;
      padding: 0.5em 1em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
    }
    #vc-controls button:disabled {
      background: #440044;
      cursor: not-allowed;
    }
    video {
      max-width: 150px;
      border: 2px solid #c399ff;
      border-radius: 8px;
      margin: 0.5em;
      background: black;
    }
    #videos {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0.5em;
      background: #220022;
      border-top: 2px solid #c399ff;
      min-height: 160px;
    }
  </style>
</head>
<body>

<header>
  SHAMELESS Chat & Voice
  <div id="usernameDisplay">Connecting...</div>
</header>

<ul id="messages"></ul>

<div id="chat-input">
  <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off" disabled />
  <button id="sendBtn" disabled>Send</button>
</div>

<div id="vc-controls">
  <button id="joinVcBtn" disabled>Join Voice Chat</button>
  <button id="leaveVcBtn" disabled>Leave Voice Chat</button>
  <button id="toggleCamBtn" disabled>Toggle Camera</button>
  <button id="toggleMicBtn" disabled>Toggle Mic</button>
  <button id="shareScreenBtn" disabled>Share Screen</button>
  <button id="stopShareScreenBtn" disabled>Stop Screen Share</button>
</div>

<div id="videos"></div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  // UI Elements
  const usernameDisplay = document.getElementById("usernameDisplay");
  const messages = document.getElementById("messages");
  const messageInput = document.getElementById("messageInput");
  const sendBtn = document.getElementById("sendBtn");
  const joinVcBtn = document.getElementById("joinVcBtn");
  const leaveVcBtn = document.getElementById("leaveVcBtn");
  const toggleCamBtn = document.getElementById("toggleCamBtn");
  const toggleMicBtn = document.getElementById("toggleMicBtn");
  const shareScreenBtn = document.getElementById("shareScreenBtn");
  const stopShareScreenBtn = document.getElementById("stopShareScreenBtn");
  const videosDiv = document.getElementById("videos");

  let localStream = null;
  let screenStream = null;
  let peers = {}; // socketId => RTCPeerConnection
  let username = null;
  let inVC = false;

  // On connect, request username assigned by server
  socket.on("connect", () => {
    socket.emit("request-username");
  });

  socket.on("assign-username", (name) => {
    username = name;
    usernameDisplay.textContent = "You are: " + username;
    messageInput.disabled = false;
    sendBtn.disabled = false;
    joinVcBtn.disabled = false;
    addSystemMessage(`Welcome, ${username}!`);
  });

  socket.on("error-message", (msg) => {
    alert(msg);
  });

  socket.on("user-joined", (name) => {
    addSystemMessage(`${name} joined the chat.`);
  });

  socket.on("user-left", (name) => {
    addSystemMessage(`${name} left the chat.`);
  });

  socket.on("chat-message", ({ username: user, message }) => {
    addChatMessage(user, message);
  });

  sendBtn.onclick = () => {
    const msg = messageInput.value.trim();
    if (!msg) return;
    socket.emit("chat-message", msg);
    messageInput.value = "";
  };

  messageInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !sendBtn.disabled) sendBtn.click();
  });

  function addChatMessage(user, message) {
    const li = document.createElement("li");
    const userSpan = document.createElement("span");
    userSpan.classList.add("username");
    userSpan.textContent = user + ": ";
    li.appendChild(userSpan);
    li.appendChild(document.createTextNode(message));
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  function addSystemMessage(message) {
    const li = document.createElement("li");
    li.style.fontStyle = "italic";
    li.textContent = message;
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  // --- WebRTC & Voice Chat --- (same as before)

  joinVcBtn.onclick = async () => {
    if (inVC) return;
    inVC = true;
    joinVcBtn.disabled = true;
    leaveVcBtn.disabled = false;
    toggleCamBtn.disabled = false;
    toggleMicBtn.disabled = false;
    shareScreenBtn.disabled = false;
    stopShareScreenBtn.disabled = true;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      addVideoStream("local", localStream, true);
      socket.emit("join-vc");
    } catch (err) {
      alert("Could not get camera/microphone: " + err.message);
      resetVCControls();
      return;
    }
  };

  leaveVcBtn.onclick = () => {
    if (!inVC) return;
    inVC = false;
    resetVCControls();
    closeAllPeers();
    removeVideoStream("local");
    removeVideoStream("screen");
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    if (screenStream) {
      screenStream.getTracks().forEach(track => track.stop());
      screenStream = null;
    }
    socket.emit("leave-vc");
  };

  toggleCamBtn.onclick = () => {
    if (!localStream) return;
    const videoTrack = localStream.getVideoTracks()[0];
    if (!videoTrack) return;
    videoTrack.enabled = !videoTrack.enabled;
    toggleCamBtn.textContent = videoTrack.enabled ? "Turn Camera Off" : "Turn Camera On";
  };

  toggleMicBtn.onclick = () => {
    if (!localStream) return;
    const audioTrack = localStream.getAudioTracks()[0];
    if (!audioTrack) return;
    audioTrack.enabled = !audioTrack.enabled;
    toggleMicBtn.textContent = audioTrack.enabled ? "Mute Mic" : "Unmute Mic";
  };

  shareScreenBtn.onclick = async () => {
    if (screenStream) return; // Already sharing
    try {
      screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      addVideoStream("screen", screenStream, true, true);

      // Add screen tracks to all peers
      for (const peerId in peers) {
        const pc = peers[peerId];
        screenStream.getTracks().forEach(track => {
          pc.addTrack(track, screenStream);
        });
      }
      shareScreenBtn.disabled = true;
      stopShareScreenBtn.disabled = false;

      // When user stops screen sharing (via browser)
      screenStream.getVideoTracks()[0].addEventListener("ended", () => {
        stopScreenShare();
      });
    } catch (err) {
      alert("Could not share screen: " + err.message);
    }
  };

  stopShareScreenBtn.onclick = () => {
    stopScreenShare();
  };

  function stopScreenShare() {
    if (!screenStream) return;
    screenStream.getTracks().forEach(track => track.stop());
    removeVideoStream("screen");
    screenStream = null;
    shareScreenBtn.disabled = false;
    stopShareScreenBtn.disabled = true;
  }

  function resetVCControls() {
    joinVcBtn.disabled = false;
    leaveVcBtn.disabled = true;
    toggleCamBtn.disabled = true;
    toggleMicBtn.disabled = true;
    shareScreenBtn.disabled = true;
    stopShareScreenBtn.disabled = true;
    toggleCamBtn.textContent = "Turn Camera Off";
    toggleMicBtn.textContent = "Mute Mic";
  }

  // Video management
  function addVideoStream(id, stream, isLocal = false, isScreen = false) {
    if (document.getElementById(id)) return;
    const video = document.createElement("video");
    video.id = id;
    video.srcObject = stream;
    video.autoplay = true;
    video.muted = isLocal; // mute local video
    if (isScreen) video.style.borderColor = "#ff99cc";
    videosDiv.appendChild(video);
  }

  function removeVideoStream(id) {
    const video = document.getElementById(id);
    if (video) {
      video.srcObject = null;
      videosDiv.removeChild(video);
    }
  }

  // WebRTC signaling
  socket.on("vc-user-joined", async (peerId) => {
    if (!inVC || peerId === socket.id) return;

    const pc = createPeerConnection(peerId);
    peers[peerId] = pc;

    // Add local tracks
    if (localStream) {
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    }
    if (screenStream) {
      screenStream.getTracks().forEach(track => pc.addTrack(track, screenStream));
    }

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit("vc-signal", { to: peerId, from: socket.id, description: pc.localDescription });
  });

  socket.on("vc-signal", async ({ from, description, candidate }) => {
    if (from === socket.id) return;
    let pc = peers[from];
    if (!pc) {
      pc = createPeerConnection(from);
      peers[from] = pc;
    }
    if (description) {
      const remoteDesc = new RTCSessionDescription(description);
      await pc.setRemoteDescription(remoteDesc);
      if (description.type === "offer") {
        if (localStream) {
          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }
        if (screenStream) {
          screenStream.getTracks().forEach(track => pc.addTrack(track, screenStream));
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("vc-signal", { to: from, from: socket.id, description: pc.localDescription });
      }
    } else if (candidate) {
      try {
        await pc.addIceCandidate(candidate);
      } catch (e) {
        console.error("Error adding ICE candidate:", e);
      }
    }
  });

  socket.on("vc-user-left", (peerId) => {
    closePeer(peerId);
  });

  function createPeerConnection(peerId) {
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit("vc-signal", { to: peerId, from: socket.id, candidate: event.candidate });
      }
    };

    pc.ontrack = (event) => {
      if (!document.getElementById(peerId)) {
        addVideoStream(peerId, event.streams[0]);
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "disconnected" || pc.connectionState === "failed" || pc.connectionState === "closed") {
        closePeer(peerId);
      }
    };

    return pc;
  }

  function closePeer(peerId) {
    const pc = peers[peerId];
    if (pc) {
      pc.close();
      delete peers[peerId];
    }
    removeVideoStream(peerId);
  }

  function closeAllPeers() {
    Object.keys(peers).forEach(closePeer);
  }

</script>
</body>
</html>
