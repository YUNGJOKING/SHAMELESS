<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SHAMELESS Chat & Voice</title>
  <style>
    /* Black & purple theme */
    body {
      margin: 0; font-family: Arial, sans-serif;
      background-color: #1a001a;
      color: #c399ff;
      display: flex; flex-direction: column; height: 100vh;
    }
    header {
      background: #330033; padding: 1em; text-align: center;
      font-size: 1.5em; font-weight: bold;
      border-bottom: 2px solid #c399ff;
    }
    #chat {
      flex: 1; overflow-y: auto; padding: 1em;
      background: #2a002a;
    }
    #messages {
      list-style: none; padding: 0; margin: 0;
      height: 250px;
      overflow-y: auto;
      border: 1px solid #660066;
      border-radius: 8px;
      background: #220022;
    }
    #messages li {
      margin-bottom: 0.5em;
      word-wrap: break-word;
    }
    #messages li span.username {
      font-weight: bold;
      color: #d9b3ff;
    }
    #chat-input {
      display: flex; background: #330033; padding: 0.5em;
      border-top: 2px solid #c399ff;
    }
    #chat-input input[type="text"] {
      flex: 1;
      padding: 0.5em;
      border: none;
      background: #1a001a;
      color: #c399ff;
      font-size: 1em;
    }
    #chat-input button {
      background: #660066;
      border: none;
      color: #c399ff;
      padding: 0 1em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
    }
    #chat-input button:disabled {
      background: #440044;
      cursor: not-allowed;
    }
    /* Username modal */
    #usernameModal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
      flex-direction: column;
      color: #c399ff;
    }
    #usernameModal input {
      font-size: 1.2em;
      padding: 0.5em;
      border: none;
      border-radius: 4px;
      margin-bottom: 1em;
      width: 250px;
      background: #1a001a;
      color: #c399ff;
      text-align: center;
    }
    #usernameModal button {
      padding: 0.6em 2em;
      font-size: 1.2em;
      background: #660066;
      border: none;
      border-radius: 4px;
      color: #c399ff;
      cursor: pointer;
    }
    #usernameModal button:disabled {
      background: #440044;
      cursor: not-allowed;
    }
    /* VC controls */
    #vc-controls {
      background: #330033;
      padding: 0.5em;
      display: flex;
      justify-content: center;
      gap: 1em;
      border-top: 2px solid #c399ff;
    }
    #vc-controls button {
      background: #660066;
      border: none;
      color: #c399ff;
      padding: 0.5em 1em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
    }
    #vc-controls button:disabled {
      background: #440044;
      cursor: not-allowed;
    }
    video {
      max-width: 150px;
      border: 2px solid #c399ff;
      border-radius: 8px;
      margin: 0.5em;
      background: black;
    }
    #videos {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0.5em;
      background: #220022;
      border-top: 2px solid #c399ff;
      min-height: 160px;
    }
  </style>
</head>
<body>

<header>SHAMELESS Chat & Voice</header>

<div id="usernameModal">
  <input type="text" id="usernameInput" placeholder="Enter your username" autocomplete="off" />
  <button id="joinBtn" disabled>Join Chat</button>
</div>

<ul id="messages"></ul>

<div id="chat-input">
  <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off" disabled />
  <button id="sendBtn" disabled>Send</button>
</div>

<div id="vc-controls">
  <button id="joinVcBtn" disabled>Join Voice Chat</button>
  <button id="leaveVcBtn" disabled>Leave Voice Chat</button>
  <button id="toggleCamBtn" disabled>Toggle Camera</button>
  <button id="toggleMicBtn" disabled>Toggle Mic</button>
  <button id="shareScreenBtn" disabled>Share Screen</button>
  <button id="stopShareScreenBtn" disabled>Stop Screen Share</button>
</div>

<div id="videos"></div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  // UI Elements
  const usernameModal = document.getElementById("usernameModal");
  const usernameInput = document.getElementById("usernameInput");
  const joinBtn = document.getElementById("joinBtn");
  const messages = document.getElementById("messages");
  const messageInput = document.getElementById("messageInput");
  const sendBtn = document.getElementById("sendBtn");
  const joinVcBtn = document.getElementById("joinVcBtn");
  const leaveVcBtn = document.getElementById("leaveVcBtn");
  const toggleCamBtn = document.getElementById("toggleCamBtn");
  const toggleMicBtn = document.getElementById("toggleMicBtn");
  const shareScreenBtn = document.getElementById("shareScreenBtn");
  const stopShareScreenBtn = document.getElementById("stopShareScreenBtn");
  const videosDiv = document.getElementById("videos");

  let localStream = null;
  let screenStream = null;
  let peers = {}; // socketId => RTCPeerConnection
  let username = null;
  let inVC = false;

  // Enable join button only if username is valid
  usernameInput.addEventListener("input", () => {
    const val = usernameInput.value.trim();
    joinBtn.disabled = !(val.length >= 3 && !/\s/.test(val));
  });

  joinBtn.onclick = () => {
    username = usernameInput.value.trim();
    socket.emit("set-username", username);
  };

  socket.on("welcome", (msg) => {
    usernameModal.style.display = "none";
    messageInput.disabled = false;
    sendBtn.disabled = false;
    joinVcBtn.disabled = false;
    addSystemMessage(msg);
  });

  socket.on("error-message", (msg) => {
    alert(msg);
  });

  socket.on("user-joined", (name) => {
    addSystemMessage(`${name} joined the chat.`);
  });

  socket.on("user-left", (name) => {
    addSystemMessage(`${name} left the chat.`);
  });

  socket.on("chat-message", ({ username: user, message }) => {
    addChatMessage(user, message);
  });

  sendBtn.onclick = () => {
    const msg = messageInput.value.trim();
    if (!msg) return;
    socket.emit("chat-message", msg);
    messageInput.value = "";
  };

  messageInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !sendBtn.disabled) sendBtn.click();
  });

  function addChatMessage(user, message) {
    const li = document.createElement("li");
    const userSpan = document.createElement("span");
    userSpan.classList.add("username");
    userSpan.textContent = user + ": ";
    li.appendChild(userSpan);
    li.appendChild(document.createTextNode(message));
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  function addSystemMessage(message) {
    const li = document.createElement("li");
    li.style.fontStyle = "italic";
    li.textContent = message;
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  // --- WebRTC & Voice Chat ---

  joinVcBtn.onclick = async () => {
    if (inVC) return;
    inVC = true;
    joinVcBtn.disabled = true;
    leaveVcBtn.disabled = false;
    toggleCamBtn.disabled = false;
    toggleMicBtn.disabled = false;
    shareScreenBtn.disabled = false;
    stopShareScreenBtn.disabled = true;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      addVideoStream("local", localStream, true);
      socket.emit("join-vc");
    } catch (err) {
      alert("Could not get camera/microphone: " + err.message);
      resetVCControls();
      return;
    }
  };

  leaveVcBtn.onclick = () => {
    if (!inVC) return;
    inVC = false;
    resetVCControls();
    closeAllPeers();
    removeVideoStream("local");
    removeVideoStream("screen");
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    if (screenStream) {
      screenStream.getTracks().forEach(track => track.stop());
      screenStream = null;
    }
    socket.emit("leave-vc");
  };

  toggleCamBtn.onclick = () => {
    if (!localStream) return;
    const videoTrack = localStream.getVideoTracks()[0];
    if (!videoTrack) return;
    videoTrack.enabled = !videoTrack.enabled;
    toggleCamBtn.textContent = videoTrack.enabled ? "Turn Camera Off" : "Turn Camera On";
  };

  toggleMicBtn.onclick = () => {
    if (!localStream) return;
    const audioTrack = localStream.getAudioTracks()[0];
    if (!audioTrack) return;
    audioTrack.enabled = !audioTrack.enabled;
    toggleMicBtn.textContent = audioTrack.enabled ? "Mute Mic" : "Unmute Mic";
  };

  shareScreenBtn.onclick = async () => {
    if (screenStream) return; // Already sharing
    try {
      screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      addVideoStream("screen", screenStream, true, true);

      // Add screen tracks to all peers
      for (const peerId in peers) {
        const pc = peers[peerId];
        screenStream.getTracks().forEach(track => {
          pc.addTrack(track, screenStream);
        });
      }
      shareScreenBtn.disabled = true;
      stopShareScreenBtn.disabled = false;

      // When user stops sharing from browser UI
      screenStream.getVideoTracks()[0].addEventListener("ended", () => {
        stopScreenShare();
      });
    } catch (err) {
      alert("Could not share screen: " + err.message);
    }
  };

  stopShareScreenBtn.onclick = () => {
    stopScreenShare();
  };

  function stopScreenShare() {
    if (!screenStream) return;
    screenStream.getTracks().forEach(track => track.stop());
    removeVideoStream("screen");

    // Remove screen tracks from all peers by renegotiation (simple approach: close and rejoin)
    // For simplicity, we just disconnect and reconnect peers:
    closeAllPeers();
    screenStream = null;
    shareScreenBtn.disabled = false;
    stopShareScreenBtn.disabled = true;

    // Rejoin VC to renegotiate without screen sharing
    if (inVC) {
      socket.emit("join-vc");
    }
  }

  function resetVCControls() {
    joinVcBtn.disabled = false;
    leaveVcBtn.disabled = true;
    toggleCamBtn.disabled = true;
    toggleMicBtn.disabled = true;
    shareScreenBtn.disabled = true;
    stopShareScreenBtn.disabled = true;
    toggleCamBtn.textContent = "Toggle Camera";
    toggleMicBtn.textContent = "Toggle Mic";
  }

  // --- Peer connections ---

  socket.on("new-peer", async (socketId) => {
    if (!inVC) return;
    if (peers[socketId]) return; // already connected

    const pc = createPeerConnection(socketId);
    peers[socketId] = pc;

    // Add local tracks
    if (localStream) {
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });
    }
    if (screenStream) {
      screenStream.getTracks().forEach(track => {
        pc.addTrack(track, screenStream);
      });
    }

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    socket.emit("signal", { to: socketId, signal: pc.localDescription });
  });

  socket.on("signal", async ({ from, signal }) => {
    if (!inVC) return;
    let pc = peers[from];
    if (!pc) {
      pc = createPeerConnection(from);
      peers[from] = pc;
    }
    await pc.setRemoteDescription(new RTCSessionDescription(signal));

    if (signal.type === "offer") {
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      if (screenStream) {
        screenStream.getTracks().forEach(track => {
          pc.addTrack(track, screenStream);
        });
      }

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit("signal", { to: from, signal: pc.localDescription });
    }
  });

  function createPeerConnection(socketId) {
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });

    pc.onicecandidate = (event) => {
      if (event.candidate) return;
      socket.emit("signal", { to: socketId, signal: pc.localDescription });
    };

    pc.ontrack = (event) => {
      const stream = event.streams[0];
      addVideoStream(socketId, stream);
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
        removeVideoStream(socketId);
        pc.close();
        delete peers[socketId];
      }
    };

    return pc;
  }

  function addVideoStream(id, stream, isLocal = false, isScreen = false) {
    let video = document.getElementById(`video-${id}`);
    if (!video) {
      video = document.createElement("video");
      video.id = `video-${id}`;
      video.autoplay = true;
      video.playsInline = true;
      if (isLocal) video.muted = true;
      if (isScreen) {
        video.style.borderColor = "#ffcc00";
      }
      videosDiv.appendChild(video);
    }
    video.srcObject = stream;
  }

  function removeVideoStream(id) {
    const video = document.getElementById(`video-${id}`);
    if (video) {
      video.srcObject = null;
      video.remove();
    }
  }

  function closeAllPeers() {
    for (const id in peers) {
      peers[id].close();
      removeVideoStream(id);
      delete peers[id];
    }
  }

  // Handle user leaving VC from other side (optional)
  socket.on("user-left", (name) => {
    // Could show a message or remove their video streams if needed
  });

  // Leave VC if server tells so (optional)
  socket.on("leave-vc", () => {
    leaveVcBtn.click();
  });

</script>

</body>
</html>
